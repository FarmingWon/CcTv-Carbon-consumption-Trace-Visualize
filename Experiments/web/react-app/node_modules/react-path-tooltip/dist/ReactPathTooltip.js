"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PathTooltip = void 0;
const tslib_1 = require("tslib");
const react_1 = tslib_1.__importStar(require("react"));
exports.PathTooltip = (props) => {
    const [hidden, setHidden] = react_1.useState(true);
    const [tooltipRect, setTooltipRect] = react_1.useState({ x: 0, y: 0, w: 0, h: 0, isLeft: false, isTop: false });
    const [fontSize,] = react_1.useState(props["fontSize"] || 12);
    const [fontFamily,] = react_1.useState(props["fontFamily"] || "sans-serif");
    const [bgColor,] = react_1.useState(props["bgColor"] || "black");
    const [textColor,] = react_1.useState(props["textColor"] || "white");
    const [rtl,] = react_1.useState(props["rtl"] || false);
    const pathRef = props.pathRef;
    const svgRef = props.svgRef;
    const textRef = react_1.createRef();
    react_1.useEffect(() => {
        const updateTooltip = (e) => {
            if (svgRef && pathRef && textRef && svgRef.current && pathRef.current && textRef.current) {
                const svgRect = svgRef.current.getBoundingClientRect();
                const textRect = textRef.current.getBoundingClientRect();
                const isLeft = ((e.x - svgRect.x) > (svgRect.width / 2));
                const isTop = ((e.y - svgRect.y) > (svgRect.height / 2));
                const w = textRect.width + 20;
                const h = textRect.height + 20;
                const x = (isLeft) ? e.x - svgRect.x + 8 - w : e.x - svgRect.x - 8;
                const y = (isTop) ? e.y - svgRect.y - 12 - h : e.y - svgRect.y + 8;
                setTooltipRect({ x: x, y: y, w: w, h: h, isLeft: isLeft, isTop: isTop });
            }
        };
        if (pathRef && pathRef.current) {
            pathRef.current.addEventListener('mouseover', () => { setHidden(false); });
            pathRef.current.addEventListener('mouseleave', () => { setHidden(true); });
            pathRef.current.addEventListener('mousemove', (e) => { if (!hidden)
                updateTooltip(e); });
        }
    }, [pathRef, svgRef, textRef, hidden]);
    const bottomRight = (tooltipRect.x + 7).toString() + "," + (tooltipRect.y - 10).toString() + " " + (tooltipRect.x + 30).toString() + "," + tooltipRect.y.toString() + " " + (tooltipRect.x + 22).toString() + "," + tooltipRect.y.toString();
    const bottomLeft = (tooltipRect.x + tooltipRect.w - 8).toString() + "," + (tooltipRect.y - 10).toString() + " " + (tooltipRect.x + tooltipRect.w - 25).toString() + "," + tooltipRect.y.toString() + " " + (tooltipRect.x + tooltipRect.w - 15).toString() + "," + tooltipRect.y.toString();
    const topRight = (tooltipRect.x + 7).toString() + "," + (tooltipRect.y + tooltipRect.h + 10).toString() + " " + (tooltipRect.x + 15).toString() + "," + (tooltipRect.y + tooltipRect.h).toString() + " " + (tooltipRect.x + 7).toString() + "," + (tooltipRect.y + tooltipRect.h).toString();
    const topLeft = (tooltipRect.x + tooltipRect.w - 7).toString() + "," + (tooltipRect.y + tooltipRect.h + 10).toString() + " " + (tooltipRect.x + tooltipRect.w - 15).toString() + "," + (tooltipRect.y + tooltipRect.h).toString() + " " + (tooltipRect.x + tooltipRect.w - 7).toString() + "," + (tooltipRect.y + tooltipRect.h).toString();
    const points = (tooltipRect.isLeft && tooltipRect.isTop) ? topLeft : (tooltipRect.isTop) ? topRight : (tooltipRect.isLeft) ? bottomLeft : bottomRight;
    const findSpaceBeforeThreshold = (inputString, threshold) => {
        let i = 0;
        let temp = -1;
        if (inputString.length <= threshold) {
            return ["", inputString];
        }
        while (i <= inputString.length && i <= threshold) {
            if (inputString[i] === " ") {
                temp = i;
            }
            i++;
        }
        return temp !== -1 ? [inputString.slice(0, temp), inputString.slice(temp + 1)] : [inputString.slice(0, threshold), inputString.slice(threshold + 1)];
    };
    const tips = [];
    const startTip = findSpaceBeforeThreshold(props.tip, 35 - (1 * fontSize - 11));
    tips.push(startTip[0]);
    let interimTip = startTip[1];
    let leftover = startTip[1];
    while (interimTip !== "") {
        const currTip = findSpaceBeforeThreshold(interimTip === leftover ? interimTip : leftover, 35 - (1 * fontSize - 11));
        interimTip = currTip[0];
        leftover = currTip[1];
        tips.push(interimTip === "" ? currTip[1] : currTip[0]);
    }
    return (react_1.default.createElement("g", { pointerEvents: "none" },
        react_1.default.createElement("rect", { x: tooltipRect.x, y: tooltipRect.y, width: tooltipRect.w, rx: 5, ry: 5, height: tooltipRect.h, fill: bgColor, visibility: (hidden ? "hidden" : "visible") }),
        react_1.default.createElement("polygon", { fill: bgColor, visibility: (hidden ? "hidden" : "visible"), points: points }),
        react_1.default.createElement("text", { ref: textRef, x: rtl ? tooltipRect.x + tooltipRect.w - 10 : tooltipRect.x + 10, y: tooltipRect.y, cursor: "default", fontFamily: fontFamily, fontSize: fontSize, fill: textColor, visibility: (hidden ? "hidden" : "visible") }, props.tip.length > 35 - (1 * (fontSize - 11))
            ?
                tips.map((tip, index) => {
                    return (react_1.default.createElement("tspan", { key: tip, x: rtl ? tooltipRect.x + tooltipRect.w - 10 : tooltipRect.x + 10, y: tooltipRect.y + (20 + (1 * fontSize - 11)) + (20 * (index)) }, tip));
                })
            :
                react_1.default.createElement("tspan", { x: rtl ? tooltipRect.x + tooltipRect.w - 10 : tooltipRect.x + 10, y: tooltipRect.y + (20 + (1 * fontSize - 11)) }, props.tip))));
};
